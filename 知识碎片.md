## css3 box-sizing属性
box-sizing 有三个属性，inherit、content-box 和 border-box，其中 content 就是我们平时用的盒装模型，它也是默认值。而 border-box 的宽有以下规律：**(固定不变)width=border+padding+剩下的宽**。当padding或者border过大时，撑开width。可以打开控制台试试下面的demo。
<div class="border-box"></div>
<style>
    .border-box {
        width: 100px;
        height: 100px;
        padding: 0px;
        border: 27px solid #ff3;
        background: #f33;
}
</style>

## vue 在子组件里获取父组件的data并改变它
可以用**vm.$parent**

## Map和Set
Map和Set是ES6中的语法
#### Map是一组键值对的结构，具有很快的查找速度。比如
``` javascript
var map = new Map([['小鱼','会游'],['小鸟','会飞'],['小狗','会叫'],['青蛙','会跳']])
// 原谅我那么幼稚-_-|||
map.get('小鱼') // 会游
map.set('小猪','会吃') // 添加了小猪会吃的键值对
map.has('小猪') // map里面是否存在该键值对（true）
map.delete('小鱼') // 删除该键值对
map.get('小鱼') // undefine
map.set('小猪','会拱') // 修改键值对
```
#### Set也是key组合，但是它不储存值，而且它没有重复的key
``` javascript
var set = new Set(['小鱼','小鸟','小狗','青蛙'])
set.add('小猪'); // 添加了一只小猪 ['小鱼','小鸟','小狗','青蛙','小猪']
set.add('小猪'); // 相同的key，上面说到不会重复，因此['小鱼','小鸟','小狗','青蛙','小猪']
set.delete('小鱼') // 删除小鱼
```

## apply和call
用来调用对象本不属于他自己的方法
``` javascript
let chicken = {
    name: "鸡",
    crow: function(){
        console.log("我是" + this.name + "，我会喔～喔～～喔～～～")
    }
};
let duck = {
    name: "鸭",
    swim: function(){
        console.log("我是" + this.name + "，我会游")
    }
};
chicken.crow(); // 我是鸡，我会喔～喔～～喔～～～
duck.swim(); // 我是鸭，我会游
```
鸡会蹄，鸭子会游泳。一天，鸡想去游泳，但是它并不会游，于是它找到了鸭，和鸭学。
#### 通过apply和call调用
``` javascript
duck.swim.apply(chicken); // 我是鸡，我会游
duck.swim.call(chicken); // 我是鸡，我会游
```
于是乎，鸡学会了游泳。但是鸭也想唱歌来增加自己的人气，它让鸡教它。
``` javascript
chicken.crow.apply(duck); // 我是鸭，我会喔～喔～～喔～～～
chicken.crow.call(duck); // 我是鸡，我会游
```
于是乎，鸭也能在早上叫你起床了。
#### 总结与区别
apply和call接收的第一个参数会变成this，谁需要调用不是它的方法，就把它放在参数的第一个位置（需要调取的函数对象）。apply的第二个参数传入的是数组，而call可以传入很多个。再来看个例子:
``` javascript
let peTeacher = {
    name: "peTeacher"
};
let mathTeacher = {
    name: "mathTeacher",
    add: function(num1, num2){
        console.log("虽然我是"+this.name+"但是我知道结果是：")
        return num1+num2;
    }
};
mathTeacher.add.apply(peTeacher,[2,3]); // 虽然我是peTeacher但是我知道结果是： 5
mathTeacher.add.call(peTeacher,2,3); // 虽然我是peTeacher但是我知道结果是： 5
```
嗯嗯～没错，他们的不同点是传入参数的方式不同。

## Flex 布局
设置flex布局后，子元素的 float、clear 和 vertical-align 属性会失效。

## 简写
``` javascript
// 1. 使用 Array.includes 来处理多重条件
// function test1(fruit) {
//   if (fruit == 'apple' || fruit == 'strawberry') {
//     console.log('red');
//   }
// }

function test1(fruit) {
    // 把条件提取到数组中
    const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries'];
    if (redFruits.includes(fruit)) {
    console.log('red');
    }
}
```

## 网页
[javascript面向对象编程，带你认识封装、继承和多态](https://cherryblog.site/javascript-oop.html)

## Promise
一句话概述： 用于解决异步中的流程控制问题

## vue路由是如何实现页面跳转的
#### hash
hash 因为有个#号的关系，所以会丑了点，但是重要的一点是服务器不会管 # 号后面的内容（即根本不会把 # 后面的内容发送给服务器），因此不用担心会出现404的情况。它的主要事件是 hashchange。
``` javascript
window.location.hash = main
```
#### history
history 有两个重要的 API ---- pushState 和 replaceState.通过这两个 API 可以改变 url 地址且不会发送请求。但是因为它就像是正常的url，当按 f5 刷新的时候会实实在在地请求服务器，如果服务器中没有相应的响应或者资源，就会抛出一个404出来。
**（比如：google.com.hk/id，history 模式下，f5 刷新时会请求这个地址，但是服务器没有配置这个地址，因此给你一个404，而 hash 模式下，地址为：google.com.hk/#/id，f5 刷时只会请求google.com.hk）**
``` javascript
history.go(-2);//后退两次
history.go(2);//前进两次
history.back(); //后退
hsitory.forward(); //前进
```
改变 hash 和 history 都不会向后台发送请求。
